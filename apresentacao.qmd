---
title: MÉTODOS DE MACHINE LEARNING PARA RECONCILIAÇÃO ÓTIMA DE SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS DE INSTITUIÇÕES FINANCEIRAS
subtitle: DEFESA DE DISSERTAÇÃO DE MESTRADO
author: Alberson Miranda, PPGEco/UFES
date: last-modified
date-format: "[Fevereiro de 2024]"
format:
    beamer:
        include-in-header: config/beamer/preamble.tex
        include-after-body: config/beamer/backmatter.tex
        keep-tex: false
        latex-max-runs: 4
        number-sections: false
        output-file: apresentacao.pdf
bibliography: config/elementos/dissertacao.bib
cite-method: biblatex
link-citations: true
link-bibliography: true
---

```{r config}
#| include = FALSE

# opções
knitr::opts_chunk$set(
    out.width = "90%"
)

# reprodutibilidade
set.seed(1)

# pacotes
pacman::p_load(
    kableExtra,
    ggplot2,
    tsibble,
    fable,
    fabletools
)

# tema ggplot
tema = theme_classic() +
    theme(
        text = element_text(family = "serif")
    )

# gerar bibliografia de pacotes
knitr::write_bib(
    c(.packages(), "basedosdados")
    , file = "config/elementos/packages.bib"
)

# scripts
source("scripts/estban/hierarq.R")
```

# CONTEXTUALIZAÇÃO DA PESQUISA

## ANÁLISE DE SÉRIES TEMPORAIS EM ECONOMIA BANCÁRIA

- Problemas populares na literatura: risco de crédito, detecção de anomalias (fraude), preços de ativos, alocação ótima de numerários [@sezer_financial_2019]
- Pouco sobre projeção de saldos e rendas (*guidance*, *budgeting*)
- Previsões equivocadas = percepção de incompetência, redução de reputação e receitas [@beccalli_earnings_2015]
- Orçamentação em empresas de muitas filiais: alta dimensionalidade e dúvidas

## ANÁLISE DE SÉRIES TEMPORAIS EM ECONOMIA BANCÁRIA

- Banestes: 134 agências, 78 municípios do ES, 13 microrregiões, 4 mesorregiões
- Qual a melhor forma de realizar projeções?
    - Individualmente por agência?
    - Apenas o total e distribuir proporcionalmente?
    - As informações por mesorregião ou microrregião são importantes?
    - Como usar toda a informação?

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

Séries temporais hierárquicas são aquelas que podem ser agregadas ou desagregadas naturalmente em uma estrutura aninhada [@hyndman_forecasting_2021]

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

![](img/hierarq.png)

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

- Cada nível traz informação diferente
- É razoável supor que exista covariância entre as previsões dos diferentes níveis
- Toda informação da estrutura pode ser útil

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

Séries temporais agrupadas são aquelas que não impõem uma única estrutura hierárquica

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

![](img/agrupadas.png)

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

![](img/hier_agrup.png)

## SÉRIES TEMPORAIS HIERÁRQUICAS E AGRUPADAS

![](img/hier_agrup_2.png)

## COERÊNCIA E RECONCILIAÇÃO

- Coerência: cada nó da hierarquia deve totalizar os nós filhos
- Não há razão para que as previsões individuais (e.g., Arima, ETS) sejam coerentes

### RECONCILIAÇÃO ÓTIMA

Reescrever as previsões de forma que elas sejam coerentes, utilizando toda a informação disponível na estrutura hierárquica, ao mesmo tempo em que minimiza a variância do erro de previsão

# OBJETIVOS

## OBJETIVO GERAL

Estudar o problema da reconciliação ótima de previsões pontuais a partir de métodos de *machine learning* em séries temporais hierárquicas e agrupadas do Banco do Estado do Espírito Santo

## OBJETIVOS ESPECÍFICOS

1. Estender a abordagem de @spiliotis_hierarchical_2021 para a reconciliação ótima de séries temporais hierárquicas *e agrupadas*;
1. Avaliar a efetividade de mais 4 implementaçãoes de métodos de ML (*lasso*, *ridge*, *elastic net*, SVM e *lightGBM*), além dos 2 propostos no trabalho original (*XGBoost* e *random forest*);
1. Propor duas variações metodológicas para obtenção da amostra de treino dos modelos de ML;
1. Obter ganhos de performance no contexto de séries temporais financeiras.

# RECONCILIAÇÃO DE SÉRIES TEMPORAIS HIERÁRQUICAS

## BOTTOM-UP

- informações apenas dos níveis mais desagregados
- soma-se para obter os níveis agregados

## TOP-DOWN

- apenas informações do nível mais agregado
- há dezenas de métodos para distribuir proporcionalmente as previsões agregadas [@gross_disaggregation_1990]
- não podem ser utilizadas no contexto de séries temporais agrupadas^[Desambiguar uma estrutura agrupada resulta em uma estrutura hierárquica, mas há necessariamente perda de informação (e.g., fixar os verbetes abaixo das agências, causaria a perca da informação do agregado dos verbetes).].

## MIDDLE-OUT

- informações apenas de um nível intermediário
- soma-se para obter os níveis agregados e distribui-se proporcionalmente para os níveis mais desagregados

## NOTAÇÃO MATRICIAL

$$
\mathbfit{\tilde{y}_t} = \mathbfit{SG\hat{y}_t}
$$ {#eq-reconciliacao1}

Em que

- $\mathbfit{\tilde{y}_t}$ é o vetor de previsões reconciliadas
- $\mathbfit{S}$ é a matriz de soma
- $\mathbfit{G}$ é a matriz de reconciliação
- $\mathbfit{\hat{y}_t}$ é o vetor de previsões base

## MATRIZ DE SOMA

$\mathbfit{S}$ mapeia a estrutura hierárquica a partir da soma dos elementos mais desagregados

$$
\begin{bmatrix}
    \tilde{y}_{t} \\
    \tilde{y}_{A,t} \\
    \tilde{y}_{B,t} \\
    \tilde{y}_{AA,t} \\
    \tilde{y}_{AB,t} \\
    \tilde{y}_{AC,t} \\
    \tilde{y}_{BA,t} \\
    \tilde{y}_{BB,t}
  \end{bmatrix}_{8 \times 1}
  =
  \begin{bmatrix}
    1 & 1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 & 1 \\
    1  & 0  & 0  & 0  & 0  \\
    0  & 1  & 0  & 0  & 0  \\
    0  & 0  & 1  & 0  & 0  \\
    0  & 0  & 0  & 1  & 0  \\
    0  & 0  & 0  & 0  & 1
  \end{bmatrix}_{8 \times 5}
  \begin{bmatrix}
    \hat{y}_{AA,t} \\
    \hat{y}_{AB,t} \\
    \hat{y}_{AC,t} \\
    \hat{y}_{BA,t} \\
    \hat{y}_{BB,t}
  \end{bmatrix}_{5 \times 1}
$$ {#eq-reconciliacao2}

\begin{center}
\scriptsize
\bf{\it{exemplo 1: matriz de soma}}
\end{center}

## MATRIZ DE RECONCILIAÇÃO

$\mathbfit{G}$ mapeia o nível mais desagregado a partir das previsões de todos os níveis da hierarquia, garantindo a coerência

$$
\begin{bmatrix}
    \tilde{y}_{t} \\
    \tilde{y}_{A, t} \\
    \tilde{y}_{B, t} \\
    \tilde{y}_{AA, t} \\
    \tilde{y}_{AB, t} \\
    \tilde{y}_{AC, t} \\
    \tilde{y}_{BA, t} \\
    \tilde{y}_{BB, t}
\end{bmatrix}_{8 \times 1}
=
\mathbfit{S}_{n \times m}
\begin{bmatrix}
    p_1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    p_2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    p_3 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    p_4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    p_5 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}_{5 \times 8}
\begin{bmatrix}
    \hat{y}_{T+h|T} \\
    \hat{y}_{A, T+h|T} \\
    \hat{y}_{B, T+h|T} \\
    \hat{y}_{AA, T+h|T} \\
    \hat{y}_{AB, T+h|T} \\
    \hat{y}_{AC, T+h|T} \\
    \hat{y}_{BA, T+h|T} \\
    \hat{y}_{BB, T+h|T}
\end{bmatrix}_{8 \times 1}
$$ {#eq-reconciliacao3}

\begin{center}
\scriptsize
\bf{\it{exemplo 2: matriz de reconciliação} top-down}
\end{center}

## MATRIZ DE RECONCILIAÇÃO

$$
\begin{bmatrix}
    \tilde{y}_{t} \\
    \tilde{y}_{A, t} \\
    \tilde{y}_{B, t} \\
    \tilde{y}_{AA, t} \\
    \tilde{y}_{AB, t} \\
    \tilde{y}_{AC, t} \\
    \tilde{y}_{BA, t} \\
    \tilde{y}_{BB, t}
\end{bmatrix}_{8 \times 1}
=
\mathbfit{S}_{8 \times 5}
\begin{bmatrix}
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}_{5 \times 8}
\begin{bmatrix}
    \hat{y}_{T+h|T} \\
    \hat{y}_{A, T+h|T} \\
    \hat{y}_{B, T+h|T} \\
    \hat{y}_{AA, T+h|T} \\
    \hat{y}_{AB, T+h|T} \\
    \hat{y}_{AC, T+h|T} \\
    \hat{y}_{BA, T+h|T} \\
    \hat{y}_{BB, T+h|T}
\end{bmatrix}_{8 \times 1}
$$ {#eq-reconciliacao4}

\begin{center}
\scriptsize
\bf{\it{exemplo 3: matriz de reconciliação} bottom-up}
\end{center}

## MATRIZ DE RECONCILIAÇÃO

E se quisermos utilizar toda a informação e não apenas parte do espaço das previsões base?

### O PROBLEMA DE PESQUISA DA RECONCILIAÇÃO ÓTIMA

Estimar uma matriz de reconciliação $\mathbfit{G}$ que utilize toda a informação disponível e com o menor erro de previsão

## MATRIZ DE RECONCILIAÇÃO

### PROBLEMA DE REGRESSÃO

- Minimização do traço da matriz de covariância dos erros das previsões reconciliadas (MinT^[[@wickramasuriya_optimal_2019].])
$$
\min_{\tilde{e}} y_{T+h} - \tilde{y}_{T+h}
$$ {#eq-mint1}

- Mínimos Quadrados Generalizados (MQG)
$$
\mathbfit{G}=(\mathbfit{S}'\mathbfit{W}_h^{\dagger}\mathbfit{S})^{-1}\mathbfit{S}'\mathbfit{W}_h^{\dagger}
$$ {#eq-mint2}

Substituindo $\mathbfit{G}$ na [@eq-reconciliacao1], temos:

$$
\mathbfit{\tilde{y}}=\mathbfit{S}(\mathbfit{S}'\mathbfit{W}_h^{\dagger}\mathbfit{S})^{-1}\mathbfit{S}'\mathbfit{W}_h^{\dagger}\mathbfit{\hat{y}_{h}}
$$ {#eq-mint3}

## RECONCILIAÇÃO POR MACHINE LEARNING

![Abordagem de reconciliação ótima por ML. Fonte: @spiliotis_hierarchical_2021](img/spiliotis.png)

# METODOLOGIA

## DADOS E VARIÁVEIS

- Estatística Bancária Mensal e por Município (Bacen)
- Municípios (IBGE)
- Saldos de crédito dos verbetes empréstimos e financiamentos
- CNPJ Banestes mas expansível para todo SFN
- 01/2003 - 12/2022
- 37.920 observações (114.480 com nós de agregação)

## DADOS E VARIÁVEIS

- Estrutura hierárquica
    - total
    - 4 mesorregiões
    - 13 microrregiões
    - 79 agências
- Estrutura agrupada
    - 2 modalidades de crédito

## PREVISÕES BASE

- Previsões para fora da amostra a serem reconciliadas
- ETS (podem ser obtidas por qualquer método, incluindo ML)
- Treino: 01/2003 - 12/2021
- Horizonte de previsão ($h$): 01/2022 - 12/2022, fora da amostra

## DESIGN DO EXPERIMENTO

Dado um conjunto de previsões base, *o quanto mais precisas elas se tornam ao se aplicar um determinado método de reconciliação*?

## DESIGN DO EXPERIMENTO

Metodologia de @spiliotis_hierarchical_2021:

1. Previsões para dentro da amostra (ETS)
1. Treino dos modelos de ML para cada $y_m$
1. Reconciliação ótima das previsões base (fora da amostra)
1. Agregação das previsões reconciliadas para obtenção dos demais níveis hierárquicos

## DESIGN DO EXPERIMENTO

### METODOLOGIA ML VERSUS MINT

As principais diferenças entre os ambas metodologias são:

- A utilização de algoritmos de ML ao invés de MQG (permitindo combinações não lineares)
- A não atribuição de peso de forma obrigatória para todos os nós da hierarquia 

- O ajuste de um modelo individual para cada série do nível mais desagregado, permitindo maior especialização e sendo capaz de se adaptar melhor aos diferentes padrões de cada série [@spiliotis_hierarchical_2021].

## DESIGN DO EXPERIMENTO

- Métodos de reconciliação:
    - Analíticos: *Bottom-up* e MinT *Shrink*
    - Regressão regularizada: *Elastic Net* (lasso, ridge e CV)
    - Árvores: *Random forest*, XGBoost e LightGBM
    - *Support Vector Machines* (SVM)
- Estratégias para obtenção das previsões *in-sample*:
    - *Rolling forecast*
    - *Reduced fitted base forecasts*
    - *Fitted base forecasts*

## ESTRATÉGIA ROLLING FORECAST

![Estratégia *Rolling Forecast*](img/modelagem_2.png){width=90%}

## ESTRATÉGIA REDUCED FITTED BASE

- Desvantagem do *Rolling Forecast*: a cada $h$, um novo modelo é ajustado, totalizando $m \times p = 17064$ modelos.
- *Reduced fitted base*: ajusta-se apenas $m$ modelos, com dados até $Q$ e então reestima-se esses modelos passando-se o restante do conjunto de treinamento ($Q+p$), conservando os hiperparâmetros originais. Os valores ajustados dos modelos reestimados são utilizados para treinar os modelos de ML.

## ESTRATÉGIA FITTED BASE

- Pode ser um problema obter previsões para dentro da amostra para séries de poucas observações ou incompletas
- *Fitted base*: utiliza-se os valores ajustados dos modelos de previsão base obtidos ao longo de todo o período $q=1,2,3,...,Q+p$ (todo conjunto de treinamento)

## OTIMIZAÇÃO DE HIPERPARÂMETROS

- @bischl_hyperparameter_2021
- $m$ modelos calibrados individualmente
- *grid* para *elastic net* e bayesiana os demais métodos
- *Resampling*: CV-10, RMSE

# RESULTADOS

## ESTBAN - ANALÍTICOS

```{r}

rbind(
  readRDS("data/estban/preds_analitico/acuracia_analiticos.rds")[["rmsse"]],
  readRDS("data/estban/preds_analitico/acuracia_analiticos.rds")[["mase"]]
 ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 3) |>
  pack_rows("MASE", 4, 6) |>
  kable_styling(latex_options = c("scale_down")) |>
  # microrregião
  column_spec(
    4,
    bold = c(F, T, F, F, T, F)
  ) |>
  # município
  column_spec(
    5,
    bold = c(T, F, F, T, F, F)
  ) |>
  # agência
  column_spec(
    6,
    bold = c(F, F, T, T, F, F)
  ) |>
  # verbete
  column_spec(
    7,
    bold = c(F, F, T, F, F, T)
  ) |>
  # bottom
  column_spec(
    8,
    bold = c(F, F, T, F, T, F)
  ) |>
  # hierarquia
  column_spec(
    9,
    bold = c(F, F, T, F, F, T)
  )
```

## ESTBAN - ML - ROLLING FORECAST

```{r}

rbind(
  readRDS("data/estban/preds_ml/preds/rolling_forecast/resumo.RDS")[["rmsse"]],
  readRDS("data/estban/preds_ml/preds/rolling_forecast/resumo.RDS")[["mase"]]
 ) |>
  # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 7) |>
  pack_rows("MASE", 8, 14) |>
  kable_styling(latex_options = c("scale_down")) |>
  # agregado
  column_spec(
    2,
    underline = c(F, F, F, F, F, F, F, F, T, F, F, F, F, F)
  )
```

## ESTBAN - ML - FITTED BASE

```{r}

rbind(
  readRDS("data/estban/preds_ml/preds/fitted_base/resumo.RDS")[["rmsse"]],
  readRDS("data/estban/preds_ml/preds/fitted_base/resumo.RDS")[["mase"]]
 ) |>
 # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 7) |>
  pack_rows("MASE", 8, 14) |>
  kable_styling(latex_options = c("scale_down"))
```

## ESTBAN - ML - REDUCED FITTED BASE

```{r}

rbind(
  readRDS("data/estban/preds_ml/preds/one-step-ahead/resumo.RDS")[["rmsse"]],
  readRDS("data/estban/preds_ml/preds/one-step-ahead/resumo.RDS")[["mase"]]
 ) |>
  # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 7) |>
  pack_rows("MASE", 8, 14) |>
  kable_styling(latex_options = c("scale_down")) |>
  # agregado
  column_spec(
    2,
    bold = c(T, F, F, F, F, F, F, T, F, F, F, F, F, F),
    underline = c(F, T, F, F, T, F, F, F, T, F, F, T, F, F)
  ) |>
  # mesorregião
  column_spec(
    3,
    bold = c(F, T, F, F, F, F, F, F, T, F, F, F, F, F)
  )
```

## ESTBAN - ML - TEMPO DE PROCESSAMENTO

```{r}

# obtendo tempo de processamento
tempo = lapply(c("one-step-ahead", "fitted_base", "rolling_forecast"), function(tipo) {
  lapply(c("xgb", "ranger", "glmnet", "lasso", "ridge", "svm", "lightgbm"), function(learner) {
    preds = readRDS(paste0("data/estban/preds_ml/preds/", tipo, "/preds_", learner, ".RDS"))[[2]]
    return(preds)
  })
})

# juntando predições em um único dataframe
tempo = do.call(rbind, tempo)

# convertendo colunas para numérico
tempo = sapply(as.data.frame(tempo), function(x) as.numeric(x))

# nomeando df
colnames(tempo) = c("xgb", "random forest", "elastic net", "lasso", "ridge", "svm", "lightgbm")
rownames(tempo) = c("reduced fitted base", "fitted base", "rolling forecast")

# tabela
tempo |>
  kbl(booktabs = TRUE, digits = 3) |>
  kable_styling(latex_options = c("scale_down"))
```

## TOURISM - ANALÍTICOS

```{r}

rbind(
  readRDS("data/tourism/preds_analitico/acuracia_analiticos.rds")[["rmsse"]],
  readRDS("data/tourism/preds_analitico/acuracia_analiticos.rds")[["mase"]]
 ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 3) |>
  pack_rows("MASE", 4, 6) |>
  kable_styling(font_size = 8) |>
  # bottom
  column_spec(
    6,
    bold = c(F, F, T, F, F, T)
  ) |>
  # hierarquia
  column_spec(
    7,
    bold = c(F, F, T, F, F, T)
  )
```

## TOURISM - ML - ROLLING FORECAST

```{r}

rbind(
  readRDS("data/tourism/preds_ml/preds/rolling_forecast/resumo.RDS")[["rmsse"]],
  readRDS("data/tourism/preds_ml/preds/rolling_forecast/resumo.RDS")[["mase"]]
 ) |>
  # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 3) |>
  pack_rows("RMSSE", 1, 7) |>
  pack_rows("MASE", 8, 14) |>
  kable_styling(font_size = 8) |>
  # agregado
  column_spec(
    2,
    bold = c(F, F, F, F, F, T, F, F, F, F, F, F, T, F),
    underline = c(F, F, F, F, T, F, F, F, F, F, F, T, F, F)
  ) |>
  # state
  column_spec(
    3,
    bold = c(F, F, F, F, F, T, F, F, F, F, F, F, T, F),
    underline = c(F, F, F, F, T, F, F, F, F, F, F, T, F, F)
  ) |>
  # purpose
  column_spec(
    5,
    bold = c(F, F, F, F, F, T, F, F, F, F, F, F, T, F),
    underline = c(F, F, F, F, T, F, F, F, F, F, F, T, F, F)
  )
```

## TOURISM - ML - FITTED BASE

```{r}

rbind(
  readRDS("data/tourism/preds_ml/preds/fitted_base/resumo.RDS")[["rmsse"]],
  readRDS("data/tourism/preds_ml/preds/fitted_base/resumo.RDS")[["mase"]]
 ) |>
 # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 2) |>
  pack_rows("RMSSE", 1, 7) |>
  pack_rows("MASE", 8, 14) |>
  kable_styling(font_size = 8) |>
  # state
  column_spec(
    3,
    underline = c(F, F, F, F, T, T, F, F, F, F, F, T, T, F)
  ) |>
  # region
  column_spec(
    4,
    bold = c(F, F, F, F, T, F, F, F, F, F, F, T, F, F)
  ) |>
  # purpose
  column_spec(
    5,
    underline = c(F, F, F, F, F, F, F, F, F, F, F, T, F, F)
  )
```

## TOURISM - ML - REDUCED FITTED BASE

```{r}

rbind(
  readRDS("data/tourism/preds_ml/preds/one-step-ahead/resumo.RDS")[["rmsse"]],
  readRDS("data/tourism/preds_ml/preds/one-step-ahead/resumo.RDS")[["mase"]]
 ) |>
 # substituindo "glmnet" por "elastic net"
  transform(
    modelo = ifelse(modelo == "glmnet", "elastic net", modelo)
  ) |>
  # substituindo "ranger" por "random forest"
  transform(
    modelo = ifelse(modelo == "ranger", "random forest", modelo)
  ) |>
  kbl(booktabs = TRUE, format = "latex", digits = 2) |>
  pack_rows("RMSSE", 1, 3) |>
  pack_rows("MASE", 4, 6) |>
  kable_styling(font_size = 8)
```

## TOURISM - ML - TEMPO DE PROCESSAMENTO

```{r}

# obtendo tempo de processamento
tempo = lapply(c("fitted_base", "rolling_forecast", "one-step-ahead"), function(tipo) {
  lapply(c("xgb", "ranger", "glmnet", "lasso", "ridge", "svm", "lightgbm"), function(learner) {
    preds = readRDS(paste0("data/tourism/preds_ml/preds/", tipo, "/preds_", learner, ".RDS"))[[2]]
    return(preds)
  })
})

# juntando predições em um único dataframe
tempo = do.call(rbind, tempo)

# convertendo colunas para numérico
tempo = sapply(as.data.frame(tempo), function(x) as.numeric(x))

# nomeando df
colnames(tempo) = c("xgb", "random forest", "elastic net", "lasso", "ridge", "svm", "lightgbm")
rownames(tempo) = c("fitted base", "rolling forecast", "reduced fitted base")

# tabela
tempo |>
  kbl(booktabs = TRUE, digits = 3) |>
  kable_styling(font_size = 8)
```

## RESULTADOS

- Os métodos baseados em árvore, além de requererem maior tempo de processamento devido a sua complexidade no espaço de hiperparâmetros, também tenderam a perder qualidade de performance nos níveis superiores da hierarquia
- Os métodos de regressão regularizada e o SVM se mostraram mais robustos à agregação
- Nenhum combinação de método/estratégia é consistentemente melhor ao longo de todos os níveis de agregação

## RESULTADOS

- Para o nível agregado, o *elastic net* na estratégia *reduced fitted base* foi 91% melhor que o MinT
- Para as mesorregiões, o Lasso superou o BU em 7%
- Nos demais níveis hierárquicos, os métodos analíticos superaram os de ML (*idem* TOURISM)

# CONCLUSÃO

## OUTLINE

- Os métodos de ML podem trazer ganhos de performance substanciais em relação aos analíticos
- A metodologia de reconciliação ótima desenvolvida neste trabalho pode ser estendida para todo o SFN e para outros problemas de previsão de séries temporais

## OUTLINE

- A escolha do método dependerá do objetivo do pesquisador:
  - Para elaboração de metas individuais, os métodos analíticos se mostraram preferíveis
  - Para previsão dos níveis mais agregados, os métodos lineares de ML obtiveram melhor performance
  - Os métodos baseados em árvore de decisão não foram capazes de superar os analíticos em nenhum nível de agregação

## OUTLINE

- Não houve uma combinação de método e estratégia que obtivesse melhor performance de maneira consistente ao longo de todos os níveis hierárquicos
- A performance da reconciliação ótima é sensível à estratégia de geração de previsões para dentro da amostra
